#include <iostream>
using namespace std;

void main()
{
	ios_base::sync_with_stdio(false);
	cin >> fixed;
	cout << fixed;

	// 암시적 생성자호출을 막기 위해 explicit을 붙여 생성자를 정의할 수 있다.
	
	// 전방 선언은 자료형의 유무를 알려줄 뿐.
	// 포인터를 통해 선언하자
	
	// 상호 참조를 피하기 위한 방법.
	// 전방 선언 : 선언부에 자료형을 선언 - 멤버로는 포인터 타입을 사용 - cpp에 헤더파일 선언한다.
	// 이렇게 해도 문제가 생길 수도 있음. 따라서, 생성자 혹은 소멸자 내에서 다른 객체 생성자 혹은 소멸자 호출 (순환 참조)를 방지하기 위해 이니셔라이저 함수 등을 쓰는 것.
	// 확보할 메모리를 미리 확정하기 위해 전방 선언을 하는 것.
	// 컴파일 시점에 알아야 할 정보를 헤더파일이 다 가지고 있다.
	// 순서 요약 : 선언, 멤버로 포인터 선언, cpp에 헤더파일 포함.
	// 전방 선언의 방법은 잘 알아두자.

	// 숙제 1. 그동안 했던 과제들로 일부러라도 전방 선언을 한 번 해보자.

	// 클래스의 멤버 변수는 객체가 생성되어야 초기화가 됨(생성자 호출이 되어야만).
	// const int m_iA; 생성자{m_iA = 100;} 와 같은 식의 경우 상수화가 진행된 이후에야 초기화가 되기 때문에 에러. 따라서 이럴 때, 이니셜라이저를 사용할 수 있다.
	// 이니셜라이저 : 클래스의 멤버인 상수나 변수를 초기화하는 문법 - 속도가 압도적으로 빠름
	// CTest(int _iA, int _iB) : m_iA(_iA), m_iB(_iB)

	// const int* p = &iA; // 읽기 전용 포인터
	// int* const p = &iA; // 상수 포인터

	// void Print(void) const // 읽기 전용 함수 : 같은 클래스의 멤버 변수의 값 변경이 
	// 위의 함 수 안에서 함수를 호출하고 싶다면 호출하려 하는 함수도 읽기 전용 함수여야 한다. 호출하는 함수 내부에서 무슨 짓을 할지 모르기 때문에.

	// 숙제 2: const를 textRpg 여기저기에 써보자. 이니셜라이저도 좀 써보고

	// void Print(void); void Print(void) const; 와 같이 const 키워드에 따른 함수 오버로딩도 가능하다.
	// explixit은 선언부에만 써줘도 상관없지만, const는 선언 및 정의부에 다 써주자.
}