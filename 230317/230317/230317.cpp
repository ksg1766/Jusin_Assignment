#include <iostream>
using namespace std;

void main()
{
	ios_base::sync_with_stdio(false);
	cin >> fixed;
	cout << fixed;

	// 상속 : 공통적인 것들을 한 자료형으로 관리하겠다.
	// 상속 받은 자식은 부모의 것을 가져다 쓸 수 있음
	// 자식은 부모의 것을 마음대로 사용할 수 있지만, 부모는 자식의 것을 사용할 수 없다.
	// 부모가 자식 것을 사용할 수 있게 만들어주는것이 다형성
	// private 상속은 거의 쓰이지 않음. 상속을 하는 이유 : 부모의 자료형으로 사용하겠다. private상속은 자료형만 갖다 쓰겠다인데, 이런걸 본적이 없다 하심.
	// (학원에서는 100% 퍼블릭 상속 사용중)
	// 반드시 부모 클래스의 헤더파일 포함.(전방선언ㄴㄴ)
	// protected는 자식에게만 접근 허용. 사실상 private느낌
	// Base와 Derived 클래스에 같은 이름으로 선언된 멤버변수를 자식클래스에서 호출하면 자식클래스의 변수가 호출됨(this때문). 물론 사실은 자식에서 두 변수 다 가지고 있음.
	// 부모의 것을 쓰고 싶다면 namespace를 사용해서 부모::멤버이름 이렇게 쓰도록 하자.
	// 자식은 부모의 변수나 함수를 가지고 태어나는 개념. 가져다 쓰는게 아님. 따라서 자식 객체의 크기가 부모객체의 크기모다 항상 크거나 같을 수 밖에 없음.
	// 공통적인 자료형으로 묶어서 쓰겠다. 아래처럼.
	// void 함수이름(파생1, 파생2);
	// void 함수이름(파생1, 파생3);
	// void 함수이름(파생3, 파생2);
	// 위 세개 대신 아래처럼.
	// void 함수이름(기반, 기반);
	// 자식 객체 생성시 메모리 할당 -> 부모 생성자 -> 자식 생성자 순으로 호출됨.
	// 소멸시에는 역순
	// UML 기호 : 클래스 간의 관계를 도식화 해놓은 체계 : 나중에 한 번 알아보자
	// 부모쪽으로 갈수록 일반화 작업이 일어나고 자식쪽으로 갈수록 구체화 작업이 일어남.
	// 상속은 대부분 is - a 관계
	// 소유할 대상이 부모가 되는 것이 has - a 관계
	// #include는 상속을 사용하지 않고 has - a 관계를 우회적으로 해결하는 방법이긴 함.
	// is - a 관계가 성립한다면 부모의 포인터로 자식의 객체를 가리킬 수 있음. (업 캐스팅)
	// 컴파일 타임에 ~~ 정적 바인딩(정적 바인딩, 동적 바인딩 찾아보자...)
}